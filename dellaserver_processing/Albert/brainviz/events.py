#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
EVENTS: for behavior-triggered averages, finding bout starts/ends, etc
06 nov 2021
@author: sama ahmed

todo
- [ ]
"""

import numpy as np


def bta(b, rho, t_range):
    """behavior-triggered average from a stimulus (b) and event indexes (rho).

    Args:
        b: time-series
        rho: idxs of "behavior events" (e.g. starts of "walk" state)
        t_range: # frames [pre, post] rho_i. pre and post are postive ints

    Returns:
        spike-triggered matrix (n-by-m), n: number of events, m: len(t_range)
    """

    # initialize with all zeroes
    bta_mat = np.zeros((len(rho), len(np.arange(-t_range[0], t_range[1] + 1))))

    for ii in range(len(rho)):
        bta_mat[ii, :] = b[rho[ii] - t_range[0]: rho[ii] + t_range[1] + 1]

    return bta_mat


def find_starts(b, event, t_range):
    """ find start events in time series

    Args:
        b: time-series, with each frame occupied by "event type"
        event: int, signfying event type of interest
        t_range: [int, int], used to exlude out-of-range indexes
    Returns:
        indexes
    """
    event_idx, = np.where(b == event)
    start_idx, = np.where(np.diff(event_idx) != 1)

    # insert -1 to capture 1st event that is lost due to diff()
    start_idx = np.insert(start_idx, 0, -1)

    if t_range is []:
        return event_idx[start_idx + 1]

    return _rm_out_of_rng(event_idx[start_idx + 1], t_range, b.shape[0])


def find_ends(b, event, t_range):
    """find ends of events in time series

    Args:
        b: time-series, with each frame occupied by "event type"
        event: int, signfying event type of interest
        t_range: [int, int], used to exlude out-of-range indexes

    Returns:
        indexes
    """
    nFrames = b.shape[0]
    rev = b[::-1]
    event_idx, = np.where(rev == event)

    _check_for_events(event_idx)

    event_idx = nFrames - event_idx
    event_idx = event_idx[::-1] - 1
    end_idx, = np.where(np.diff(event_idx) != 1)
    final = event_idx[end_idx]

    if t_range is []:
        return np.append(final, event_idx[-1])

    return _rm_out_of_rng(np.append(final, event_idx[-1]), t_range, nFrames)


def find_boundaries(b, event_A: int, event_B: int, t_range):
    """find indexes where event_A is followed by event_B

    Args:
        b: time-series, with each frame occupied by "event type"
        event: int, signfying event type of interest
        t_range: [int, int], used to exlude out-of-range indexes

    Returns:
        indexes
    """

    # find idxs where event_A ends
    end_idx = find_ends(b, event_A, t_range)
    boundary_idx = []
    for ii in end_idx:
        # keep idx if succeeding idx is event_B
        if b[ii + 1] == event_B:
            boundary_idx.append(ii)

    return boundary_idx


def transition_matrix(transitions, doCounts=False):
    """ generate transition probabilities from time series of states

    Args:
        transitions: time-series, with each frame occupied by "event type"
            e.g. transitions = np.array([0, 1, 2, 1, 1, 1, 0, 2])
        doCounts: bool, returns count of transition events instead of fractions

    Returns:
        M: transition matrix
    """
    n = 1 + max(transitions)  # number of states
    M = [[0] * n for _ in range(n)]

    for (i, j) in zip(transitions, transitions[1:]):
        M[i][j] += 1

    if doCounts:
        for row in M:
            row[:] = [f for f in row]
        return M

    # convert to fractions
    for row in M:
        s = sum(row)
        if s > 0:
            row[:] = [f / s for f in row]
    return M


# ----------------------------------------------------------------------------
# plotting and visualizing
# ----------------------------------------------------------------------------


def print_transition_matrix(M):
    """for visualizing transition matrix M generated by transition_matrix()"""
    for row in M:
        print(' '.join('{0:.2f}'.format(x) for x in row))
    return None


# ----------------------------------------------------------------------------
# helpers
# ----------------------------------------------------------------------------


def _check_for_events(event_idx):
    """helper: checks if events exist"""
    try:
        event_idx[0]
    except IndexError:
        print("IndexError: No events found in array my friend.")


def _rm_out_of_rng(x, t_range, n):
    """when finding event idxs, remove out of range idxs"""
    x2 = [a for a in x if a > t_range[0]]
    return [a for a in x2 if a < (n - t_range[1])]
